# Int128 Benchmark Harness

This repository hosts experimental infrastructure for building and benchmarking high-performance `Int128`
implementations geared towards low-latency financial workloads.

## Building

```
mvn clean package
```

The command produces a runnable JMH fat-jar under `target/int128-0.1.0-SNAPSHOT-shaded.jar`.

## Running Benchmarks

You can execute every benchmark via:

```
mvn clean install
mvn jmh:jmh
```

Alternatively, run the shaded JAR directly:

```
java -jar target/int128-0.1.0-SNAPSHOT-shaded.jar
```

To focus on a particular implementation or benchmark, use standard JMH filters, for example:

```
java -jar target/int128-0.1.0-SNAPSHOT-shaded.jar Int128ArithmeticBenchmark.additionWithReuse
```

## Adding New Implementations

1. Implement `com.symguac.int128.api.Int128Arithmetic`.
2. Register the implementation in `com.symguac.int128.bench.Int128BenchmarkRegistry` under a unique identifier.
3. Add that identifier to the `@Param` annotation inside `Int128ArithmeticBenchmark.BenchmarkState` so it can be selected
   from the command line:

   ```java
   @Param({Int128ImplementationIds.TWO_LONGS_BASELINE, "yourNewId"})
   ```

4. Rebuild and rerun the benchmarks.

The baseline `twoLongsBaseline` implementation emphasises readability and correctness; it is intentionally conservative
so that more optimised variants can be compared against a trustworthy reference.
